# 退貨訂單誤撥代收款 - 實際執行方案

## 查詢邏輯說明

### 使用 Detail_Status_Description 判斷

**正常訂單的狀態**:
- `'買家已取件'`
- `'消費者成功取件'`

**異常訂單** (退貨/取消/逾期等):
- 所有**不是**上述兩種狀態的訂單

---

## 步驟 1:查詢被誤撥的退貨訂單

### 1-1. 查詢特定撥款日的誤撥訂單

```sql
-- ========================================
-- 查詢 10/17 被誤撥的退貨/異常訂單
-- ========================================
SELECT
    oa.*,
    oi.Detail_Status,
    oi.Detail_Status_Description,
    oi.ReconciliationResult,
    bm.mem_Branchwebname AS MerchantName,
    bm.bank_account,
    bm.account_name
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
WHERE oa.LogisticNumber IN (
    SELECT LogisticNumber
    FROM Order_Info
    WHERE LogisticNumber IN (
        SELECT LogisticNumber
        FROM Order_Accounting
        WHERE GrantdaisouDate = '2025-10-17 00:00:00.000'
    )
    AND Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
)
ORDER BY oa.CheckoutdaisouDate, oa.user_account;
```

### 1-2. 查詢所有撥款日的誤撥訂單 (10/1, 10/8, 10/17)

```sql
-- ========================================
-- 查詢所有已撥款但異常的訂單
-- ========================================
SELECT
    oa.LogisticNumber,
    oa.sno,
    oa.user_account,
    oa.sonid,
    oa.Logistic_service,
    oa.OrderNo,
    oa.TotalAmount,
    oa.Service_fee,
    oa.cost,
    oa.CheckoutdaisouDate,
    oa.GrantdaisouDate,
    oi.Detail_Status,
    oi.Detail_Status_Description,
    oi.ReconciliationResult,
    bm.mem_Branchwebname AS MerchantName,
    bm.bank_account,
    bm.account_name,
    CASE
        WHEN oi.Detail_Status_Description LIKE '%退貨%' THEN '退貨'
        WHEN oi.Detail_Status_Description LIKE '%取消%' THEN '取消'
        WHEN oi.Detail_Status_Description LIKE '%逾期%' THEN '逾期未取'
        WHEN oi.Detail_Status_Description LIKE '%拒收%' THEN '拒收'
        ELSE '其他異常'
    END AS 異常類型
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
WHERE oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08', '2025-10-17')
    AND oi.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
    AND oa.DeliverMode = '01'  -- 代收
ORDER BY oa.GrantdaisouDate, oa.user_account, oa.LogisticNumber;
```

### 1-3. 統計誤撥金額 (按商家和撥款日)

```sql
-- ========================================
-- 統計各商家在不同撥款日的誤撥金額
-- ========================================
SELECT
    oa.GrantdaisouDate AS 撥款日,
    oa.user_account,
    oa.sonid,
    bm.mem_Branchwebname AS 商家名稱,
    CASE
        WHEN oi.Detail_Status_Description LIKE '%退貨%' THEN '退貨'
        WHEN oi.Detail_Status_Description LIKE '%取消%' THEN '取消'
        WHEN oi.Detail_Status_Description LIKE '%逾期%' THEN '逾期未取'
        WHEN oi.Detail_Status_Description LIKE '%拒收%' THEN '拒收'
        ELSE '其他異常'
    END AS 異常類型,
    COUNT(*) AS 誤撥訂單數,
    SUM(oa.TotalAmount) AS 誤撥代收款總額,
    SUM(oa.Service_fee) AS 服務費總額,
    SUM(oa.cost) AS 成本總額,
    -- 商家實際收到的金額 = 代收款 - 服務費
    SUM(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS 商家實收金額,
    -- 商家需要補償的金額 (負數表示要扣回)
    -SUM(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS 需補償金額
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
WHERE oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08', '2025-10-17')
    AND oi.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
    AND oa.DeliverMode = '01'
GROUP BY
    oa.GrantdaisouDate,
    oa.user_account,
    oa.sonid,
    bm.mem_Branchwebname,
    CASE
        WHEN oi.Detail_Status_Description LIKE '%退貨%' THEN '退貨'
        WHEN oi.Detail_Status_Description LIKE '%取消%' THEN '取消'
        WHEN oi.Detail_Status_Description LIKE '%逾期%' THEN '逾期未取'
        WHEN oi.Detail_Status_Description LIKE '%拒收%' THEN '拒收'
        ELSE '其他異常'
    END
ORDER BY oa.GrantdaisouDate, 需補償金額 ASC;
```

### 1-4. 總覽統計 (按商家彙總所有撥款日)

```sql
-- ========================================
-- 總覽:各商家總計需補償金額
-- ========================================
SELECT
    oa.user_account,
    oa.sonid,
    bm.mem_Branchwebname AS 商家名稱,
    bm.bank_code AS 銀行代碼,
    bm.bank_account AS 銀行帳號,
    bm.account_name AS 戶名,
    COUNT(DISTINCT oa.GrantdaisouDate) AS 涉及撥款次數,
    COUNT(*) AS 誤撥訂單總數,
    SUM(oa.TotalAmount) AS 誤撥代收款總額,
    SUM(oa.Service_fee) AS 服務費總額,
    SUM(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS 商家實收總額,
    -SUM(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS 需補償總金額
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
WHERE oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08', '2025-10-17')
    AND oi.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
    AND oa.DeliverMode = '01'
GROUP BY
    oa.user_account,
    oa.sonid,
    bm.mem_Branchwebname,
    bm.bank_code,
    bm.bank_account,
    bm.account_name
ORDER BY 需補償總金額 ASC;
```

---

## 步驟 2:建立補償記錄

### 2-1. 建立補償記錄表

```sql
-- ========================================
-- 建立補償記錄表
-- ========================================
IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Grant_Compensation')
BEGIN
    CREATE TABLE Grant_Compensation (
        CompensationID INT IDENTITY(1,1) PRIMARY KEY,
        LogisticNumber VARCHAR(50) NOT NULL,
        sno INT NOT NULL,
        user_account VARCHAR(50) NOT NULL,
        sonid VARCHAR(50) NOT NULL,
        Logistic_service VARCHAR(10),
        OrderNo VARCHAR(50),
        OriginalGrantDate DATE,  -- 原本的撥款日
        CompensationType VARCHAR(50),  -- 補償類型:'退貨誤撥'/'取消誤撥'/'逾期誤撥'
        AbnormalStatus NVARCHAR(100),  -- 異常狀態描述
        CompensationAmount DECIMAL(18,2),  -- 需要補償的金額 (負數表示要扣款)
        TotalAmount INT,  -- 原代收款金額
        Service_fee DECIMAL(18,2),  -- 服務費
        cost DECIMAL(18,2),  -- 成本
        DeductedGrantDate DATE NULL,  -- 實際扣款日期
        DeductedAmount DECIMAL(18,2) NULL,  -- 實際扣款金額
        Status VARCHAR(20) DEFAULT 'Pending',  -- 狀態:'Pending'/'Deducted'/'PartialDeducted'/'Cancelled'
        Remark NVARCHAR(500),  -- 備註
        CreateDate DATETIME DEFAULT GETDATE(),
        UpdateDate DATETIME,
        CONSTRAINT FK_Grant_Compensation_Order
            FOREIGN KEY (LogisticNumber, sno)
            REFERENCES Order_Accounting(LogisticNumber, sno)
    );

    -- 建立索引
    CREATE INDEX IX_Grant_Compensation_UserAccount
        ON Grant_Compensation(user_account, sonid, Status);
    CREATE INDEX IX_Grant_Compensation_GrantDate
        ON Grant_Compensation(OriginalGrantDate);
    CREATE INDEX IX_Grant_Compensation_Status
        ON Grant_Compensation(Status, DeductedGrantDate);

    PRINT '補償記錄表建立成功';
END
ELSE
BEGIN
    PRINT '補償記錄表已存在';
END
GO
```

### 2-2. 插入誤撥訂單的補償記錄

```sql
-- ========================================
-- 插入所有誤撥訂單的補償記錄
-- ========================================
INSERT INTO Grant_Compensation (
    LogisticNumber,
    sno,
    user_account,
    sonid,
    Logistic_service,
    OrderNo,
    OriginalGrantDate,
    CompensationType,
    AbnormalStatus,
    CompensationAmount,
    TotalAmount,
    Service_fee,
    cost,
    Status,
    Remark,
    CreateDate
)
SELECT
    oa.LogisticNumber,
    oa.sno,
    oa.user_account,
    oa.sonid,
    oa.Logistic_service,
    oa.OrderNo,
    oa.GrantdaisouDate AS OriginalGrantDate,
    -- 判斷補償類型
    CASE
        WHEN oi.Detail_Status_Description LIKE '%退貨%' THEN '退貨誤撥'
        WHEN oi.Detail_Status_Description LIKE '%取消%' THEN '取消誤撥'
        WHEN oi.Detail_Status_Description LIKE '%逾期%' THEN '逾期誤撥'
        WHEN oi.Detail_Status_Description LIKE '%拒收%' THEN '拒收誤撥'
        ELSE '其他異常誤撥'
    END AS CompensationType,
    oi.Detail_Status_Description AS AbnormalStatus,
    -- 補償金額 = -(代收款 - 服務費),負數表示要從商家扣回
    -(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS CompensationAmount,
    oa.TotalAmount,
    oa.Service_fee,
    oa.cost,
    'Pending' AS Status,
    '10/1、10/8、10/17 撥款日誤撥非正常取件訂單,需回扣代收款' AS Remark,
    GETDATE()
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
WHERE oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08', '2025-10-17')
    AND oi.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
    AND oa.DeliverMode = '01'
    -- 避免重複插入
    AND NOT EXISTS (
        SELECT 1
        FROM Grant_Compensation gc
        WHERE gc.LogisticNumber = oa.LogisticNumber
            AND gc.sno = oa.sno
            AND gc.OriginalGrantDate = oa.GrantdaisouDate
    );

-- 查看插入結果
SELECT
    '插入補償記錄筆數' AS 項目,
    @@ROWCOUNT AS 數量;

-- 查看插入的記錄摘要
SELECT
    CompensationType AS 補償類型,
    Status AS 狀態,
    COUNT(*) AS 訂單數,
    SUM(CompensationAmount) AS 補償金額
FROM Grant_Compensation
WHERE CreateDate >= DATEADD(MINUTE, -5, GETDATE())  -- 最近5分鐘建立的
GROUP BY CompensationType, Status
ORDER BY CompensationType;
```

### 2-3. 驗證插入結果

```sql
-- ========================================
-- 驗證補償記錄是否正確
-- ========================================
SELECT
    gc.OriginalGrantDate AS 原撥款日,
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS 商家名稱,
    gc.CompensationType AS 補償類型,
    COUNT(*) AS 訂單數,
    SUM(gc.CompensationAmount) AS 需補償金額,
    SUM(gc.TotalAmount) AS 代收款總額,
    SUM(gc.Service_fee) AS 服務費總額
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
WHERE gc.Status = 'Pending'
GROUP BY
    gc.OriginalGrantDate,
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname,
    gc.CompensationType
ORDER BY gc.OriginalGrantDate, 需補償金額 ASC;
```

---

## 步驟 3:建立撥款時自動扣除的 SP

```sql
-- ========================================
-- 建立處理補償扣除的 Stored Procedure
-- ========================================
CREATE OR ALTER PROCEDURE SP_GetPendingCompensation
    @user_account VARCHAR(50),
    @sonid VARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    -- 查詢該商家待扣除的補償總額
    SELECT
        user_account,
        sonid,
        SUM(CompensationAmount) AS TotalCompensation,
        COUNT(*) AS PendingCount
    FROM Grant_Compensation
    WHERE user_account = @user_account
        AND sonid = @sonid
        AND Status = 'Pending'
    GROUP BY user_account, sonid;
END
GO

-- ========================================
-- 建立更新補償扣除狀態的 SP
-- ========================================
CREATE OR ALTER PROCEDURE SP_UpdateCompensationDeducted
    @user_account VARCHAR(50),
    @sonid VARCHAR(50),
    @DeductedGrantDate DATE,
    @DeductedAmount DECIMAL(18,2)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;

    BEGIN TRY
        -- 更新補償記錄為已扣除
        UPDATE Grant_Compensation
        SET Status = 'Deducted',
            DeductedGrantDate = @DeductedGrantDate,
            DeductedAmount = @DeductedAmount,
            UpdateDate = GETDATE()
        WHERE user_account = @user_account
            AND sonid = @sonid
            AND Status = 'Pending';

        -- 記錄更新筆數
        DECLARE @UpdatedCount INT = @@ROWCOUNT;

        COMMIT TRANSACTION;

        -- 返回更新結果
        SELECT
            @UpdatedCount AS UpdatedCount,
            @DeductedAmount AS DeductedAmount,
            @DeductedGrantDate AS DeductedGrantDate;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

-- 測試 SP
EXEC SP_GetPendingCompensation @user_account = 'test_account', @sonid = '1';
```

---

## 步驟 4:修改撥款程式邏輯

### 在 OrderController.cs 的 Grant_AndC2CReport 方法中加入

```csharp
// ========================================
// 新增:檢查並扣除補償金額
// ========================================

// 1. 在撥款前,先查詢所有商家的待扣補償金額
Dictionary<string, decimal> compensationDict = GetPendingCompensations(userAccountList);

// 2. 在計算每筆撥款金額時
decimal grantAmount = totalAmount - serviceFee;  // 原本應撥款金額

string accountKey = $"{userAccount}_{sonid}";
if (compensationDict.ContainsKey(accountKey))
{
    decimal compensation = compensationDict[accountKey];  // 負數
    grantAmount += compensation;  // 扣除補償金額

    // 記錄此次扣除
    LogCompensationDeduction(userAccount, sonid, GrantDate, compensation);
}

// 3. 如果扣除後金額小於等於0,特殊處理
if (grantAmount <= 0)
{
    // 記錄到異常報表,不執行撥款
    LogZeroOrNegativeGrant(userAccount, sonid, grantAmount, compensation);
    continue;  // 跳過此商家
}

// ========================================
// 輔助方法
// ========================================
private Dictionary<string, decimal> GetPendingCompensations(List<string> userAccounts)
{
    Dictionary<string, decimal> result = new Dictionary<string, decimal>();

    string sql = @"
        SELECT
            user_account + '_' + sonid AS AccountKey,
            SUM(CompensationAmount) AS TotalCompensation
        FROM Grant_Compensation
        WHERE Status = 'Pending'
        GROUP BY user_account, sonid
    ";

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();
        using (SqlCommand cmd = new SqlCommand(sql, conn))
        {
            using (SqlDataReader reader = cmd.ExecuteReader())
            {
                while (reader.Read())
                {
                    string key = reader["AccountKey"].ToString();
                    decimal amount = Convert.ToDecimal(reader["TotalCompensation"]);
                    result[key] = amount;
                }
            }
        }
    }

    return result;
}

private void LogCompensationDeduction(string userAccount, string sonid, string grantDate, decimal amount)
{
    string sql = @"
        EXEC SP_UpdateCompensationDeducted
            @user_account = @UserAccount,
            @sonid = @Sonid,
            @DeductedGrantDate = @GrantDate,
            @DeductedAmount = @Amount
    ";

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        conn.Open();
        using (SqlCommand cmd = new SqlCommand(sql, conn))
        {
            cmd.Parameters.AddWithValue("@UserAccount", userAccount);
            cmd.Parameters.AddWithValue("@Sonid", sonid);
            cmd.Parameters.AddWithValue("@GrantDate", grantDate);
            cmd.Parameters.AddWithValue("@Amount", amount);
            cmd.ExecuteNonQuery();
        }
    }
}
```

---

## 步驟 5:查詢補償執行狀況

### 5-1. 查詢各商家補償狀態

```sql
-- ========================================
-- 查詢補償執行狀況
-- ========================================
SELECT
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS 商家名稱,
    gc.Status AS 補償狀態,
    COUNT(*) AS 訂單數,
    SUM(gc.CompensationAmount) AS 補償金額,
    SUM(ISNULL(gc.DeductedAmount, 0)) AS 已扣除金額,
    SUM(gc.CompensationAmount) - SUM(ISNULL(gc.DeductedAmount, 0)) AS 待扣除金額,
    MIN(gc.CreateDate) AS 建立時間,
    MAX(gc.DeductedGrantDate) AS 最後扣除日期
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
GROUP BY
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname,
    gc.Status
ORDER BY gc.Status, 待扣除金額 ASC;
```

### 5-2. 匯出完整補償明細 (供對帳)

```sql
-- ========================================
-- 匯出完整補償明細
-- ========================================
SELECT
    gc.CompensationID AS 編號,
    gc.LogisticNumber AS 物流單號,
    gc.OrderNo AS 訂單編號,
    gc.user_account AS 商家帳號,
    gc.sonid AS 分店編號,
    bm.mem_Branchwebname AS 商家名稱,
    gc.Logistic_service AS 物流服務,
    gc.CompensationType AS 補償類型,
    gc.AbnormalStatus AS 異常狀態,
    gc.OriginalGrantDate AS 原撥款日,
    gc.TotalAmount AS 代收款,
    gc.Service_fee AS 服務費,
    gc.cost AS 成本,
    gc.CompensationAmount AS 需補償金額,
    gc.DeductedGrantDate AS 扣款日期,
    gc.DeductedAmount AS 實扣金額,
    gc.Status AS 狀態,
    gc.Remark AS 備註,
    gc.CreateDate AS 建立時間,
    gc.UpdateDate AS 更新時間
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
ORDER BY gc.CreateDate, gc.user_account, gc.LogisticNumber;
```

---

## 步驟 6:預防措施

### 修改壓代收請款日的邏輯

在 `WeeklySettlement` 或相關的壓 `CheckoutdaisouDate` 程式中,加入檢查:

```sql
-- 壓代收請款日時,排除非正常取件的訂單
UPDATE oa
SET CheckoutdaisouDate = @SettlementDate
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
WHERE oa.CheckoutDate >= @StartDate
    AND oa.CheckoutDate < @EndDate
    AND oa.CheckoutdaisouDate IS NULL
    AND oa.GrantdaisouDate IS NULL
    AND oi.ReconciliationResult = 'Y'
    AND oa.Checkoutable = '1'
    -- ★ 重點:只壓正常取件的訂單 ★
    AND oi.Detail_Status_Description IN ('買家已取件', '消費者成功取件')
    -- 其他原有條件...
```

### 修改撥款查詢的邏輯

在 `Cls_Order.cs` 的 `Sel_OrderForGrant` 方法中:

```csharp
sqlstr += @"
    INNER JOIN Order_Info oi
        ON Order_Accounting.LogisticNumber = oi.LogisticNumber
        AND Order_Accounting.sno = oi.sno
    WHERE ...
        -- ★ 重點:只撥正常取件的訂單 ★
        AND oi.Detail_Status_Description IN ('買家已取件', '消費者成功取件')
";
```

---

## 總結檢查清單

### ✅ 執行前確認

- [ ] 備份 `Order_Accounting`, `Order_Info`, `Grant_History` 相關資料表
- [ ] 在測試環境執行所有查詢,確認邏輯正確
- [ ] 人工核對統計金額,確保計算無誤
- [ ] 確認受影響的商家數量和金額

### ✅ 執行步驟

1. [ ] 執行步驟1的查詢,匯出誤撥訂單清單
2. [ ] 建立 `Grant_Compensation` 表 (步驟2-1)
3. [ ] 插入補償記錄 (步驟2-2)
4. [ ] 驗證插入結果 (步驟2-3)
5. [ ] 建立相關 SP (步驟3)
6. [ ] 修改撥款程式碼 (步驟4)
7. [ ] 實施預防措施 (步驟6)

### ✅ 執行後追蹤

- [ ] 每次撥款後檢查補償扣除狀況
- [ ] 定期檢視 `Status='Pending'` 的補償記錄
- [ ] 監控是否還有新的誤撥發生
- [ ] 更新操作文件和 SOP

---

## 備註

**重要提醒**:
- 補償金額是**負數**,表示要從商家扣回
- 實際撥款金額 = 應撥款 + 補償金額 (因為補償是負數,所以是相減)
- 如果扣除後金額≤0,需要特殊處理 (不撥款,記錄到異常)
