# 退貨誤撥 - 欠費與結算處理方案

## 📋 現有機制說明

### 1. 前期欠費(Grant_History)機制

**資料表**: `Grant_History`

**用途**: 記錄撥款金額為**負數**的商家欠費

**運作流程**:
```csharp
// OrderController.cs 第 1388-1414 行
if (Convert.ToInt32(obj_grant_result.GrantTotalAmount) > 0)
{
    // 檢查是否有前期未結算負數帳款
    if (Obj_Grant_HistoryresultList.Count > 0)
    {
        // 比對商家(user_account + bank_code + bank_branch_code + bank_account)
        var Obj_Grant_resultlist2 = Obj_Grant_HistoryresultList
            .Where(c => c.user_account == obj_grant_result.user_account)
            .Where(c => c.bank_code == obj_grant_result.bank_code)
            .Where(c => c.bank_branch_code == obj_grant_result.bank_branch_code)
            .Where(c => c.bank_account == obj_grant_result.bank_account);

        // 如果商家有欠款
        if (Obj_Grant_resultlist2.Count() > 0)
        {
            foreach (Obj_Grant_result obj_Historygrant_result in Obj_Grant_resultlist2)
            {
                // 累加商家欠款金額 (負數)
                Grant_deductAmount += Convert.ToInt32(obj_Historygrant_result.GrantTotalAmount);
            }
        }
    }

    if (Grant_deductAmount < 0)
    {
        // 前期未繳結算服務費,從本次撥款扣除
        GrantTotalAmount = Convert.ToInt32(obj_grant_result.GrantTotalAmount) + Grant_deductAmount;
        obj_grant_result.Grant_deductAmount = Grant_deductAmount.ToString();
    }
    else
    {
        // 沒有前期未繳結算服務費
        GrantTotalAmount = Convert.ToInt32(obj_grant_result.GrantTotalAmount);
        obj_grant_result.Grant_deductAmount = "0";
    }
}
```

**關鍵邏輯**:
1. 每次撥款時,查詢 `Sel_Grant_History()` SP 取得有欠費的商家
2. 如果商家本次撥款金額 > 0,且有前期欠費(負數)
3. 自動從本次撥款扣除前期欠費: `實撥款 = 應撥款 + 前期欠費(負數)`
4. 範例: 應撥 10,000,前期欠 -3,000,實撥 = 10,000 + (-3,000) = 7,000

### 2. 結算扣額度機制

**運作時機**: 撥款完成後

**兩種結算扣除**:

#### A. 一般結算扣額度 (OrderController.cs 第 1620-1631 行)
```csharp
string QuotaResult = cls_member.Up_memQuotaAndAddHistory(new Obj_AddQuotaHistory()
{
    user_account = obj_grant_result.user_account,
    QuotaChange = Convert.ToInt32(deduct),  // 扣除金額
    ChangeType = QuotaChangeEnum.DeductQuotaSettlement,  // 結算扣除
    ChangeReason = "結算扣除額度",
    Logistic_service = "00",
    LogisticNumber = "",
    paymentno = "",
    sno = "0",
    ChangDate = DateTime.Now.ToString("yyyyMMdd")
});
```

#### B. 前期負數結算扣額度 (OrderController.cs 第 1636-1653 行)
```csharp
// 前期的未結紀錄
foreach (Obj_Grant_result obj_grant_result in Obj_Grant_HistoryresultList)
{
    // 根據實撥金額去倒扣商家額度
    decimal deduct = Convert.ToDecimal(obj_grant_result.GrantTotalAmount);
    cls_order.Up_Grant_History_txtName(obj_grant_result, grantTxtResult.AchTxtName);

    string QuotaResult = cls_member.Up_memQuotaAndAddHistory(new Obj_AddQuotaHistory()
    {
        user_account = obj_grant_result.user_account,
        QuotaChange = Convert.ToInt32(deduct),  // 負數扣除
        ChangeType = QuotaChangeEnum.DeductNegativeQuotaSettlement,  // 負數結算扣除
        ChangeReason = "結算扣除負數額度",
        Logistic_service = "00",
        LogisticNumber = "",
        paymentno = "",
        sno = "0",
        ChangDate = DateTime.Now.ToString("yyyyMMdd")
    });
}
```

**關鍵邏輯**:
1. **一般結算**: 從商家額度扣除 `實際撥款金額`
2. **前期負數結算**: 如果商家有前期欠費被本次扣除,也要從額度扣除該欠費金額

---

## 🎯 誤撥退貨訂單的補救方案

### 問題分析

從你的 SQL 查詢:
```sql
select *,TotalAmount-Service_fee-m as d from(
    select user_account,
           sum(TotalAmount) TotalAmount,
           sum(Service_fee) Service_fee,
           (
               select sum(TotalAmount)
               from Order_Info
               where LogisticNumber in (
                   select LogisticNumber
                   from Order_Accounting
                   where GrantdaisouDate > '2025/10/15 00:00:00'
               )
               and Detail_Status_Description != '買家已取件'
               and Detail_Status_Description != '消費者成功取件'
               and user_account=Order_Accounting.user_account
           ) as m
    from Order_Accounting
    where GrantdaisouDate > '2025/10/15 00:00:00'
    group by user_account
) a
order by d
```

**計算邏輯**:
- `TotalAmount` = 該商家所有撥款的代收款總額
- `Service_fee` = 該商家所有撥款的服務費總額
- `m` = 該商家異常訂單(退貨/取消)的代收款總額
- `d` = `TotalAmount - Service_fee - m` = **商家實際應收金額 - 異常代收款**

### 補救方案設計

#### 方案選擇判斷

根據 `d` 值決定:

| d 值 | 說明 | 處理方式 |
|------|------|---------|
| **d > 0** | 扣除異常後,商家還有正數可撥款 | 不寫欠費,下次撥款直接扣除 |
| **d = 0** | 扣除異常後,剛好歸零 | 不寫欠費,也不撥款 |
| **d < 0** | 扣除異常後,商家變成欠費 | **寫入 Grant_History** |

---

## 📝 補救方案 SQL

### 步驟 1: 查詢需要處理的商家

```sql
-- ========================================
-- 查詢誤撥商家的應處理金額
-- ========================================
WITH MerchantSummary AS (
    SELECT
        oa.user_account,
        oa.sonid,
        bm.mem_Branchwebname AS MerchantName,
        bm.bank_code,
        bm.bank_branch_code,
        bm.bank_account,
        bm.account_name,
        SUM(oa.TotalAmount) AS TotalAmount,  -- 所有撥款的代收款總額
        SUM(oa.Service_fee) AS Service_fee,  -- 服務費總額
        SUM(oa.cost) AS cost,  -- 成本總額
        -- 計算異常訂單的代收款總額
        (
            SELECT ISNULL(SUM(oi2.TotalAmount), 0)
            FROM Order_Accounting oa2
            INNER JOIN Order_Info oi2
                ON oa2.LogisticNumber = oi2.LogisticNumber
                AND oa2.sno = oi2.sno
            WHERE oa2.GrantdaisouDate > '2025-10-15 00:00:00'
                AND oa2.user_account = oa.user_account
                AND oa2.sonid = oa.sonid
                AND oi2.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
        ) AS AbnormalAmount
    FROM Order_Accounting oa
    INNER JOIN Branch_Member bm
        ON oa.user_account = bm.user_account
        AND oa.sonid = bm.sonid
    WHERE oa.GrantdaisouDate > '2025-10-15 00:00:00'
        AND oa.DeliverMode = '01'
    GROUP BY
        oa.user_account,
        oa.sonid,
        bm.mem_Branchwebname,
        bm.bank_code,
        bm.bank_branch_code,
        bm.bank_account,
        bm.account_name
)
SELECT
    user_account,
    sonid,
    MerchantName,
    bank_code,
    bank_branch_code,
    bank_account,
    account_name,
    TotalAmount,  -- 代收款總額
    Service_fee,  -- 服務費總額
    cost,  -- 成本總額
    AbnormalAmount,  -- 異常代收款
    (TotalAmount - Service_fee) AS NetAmount,  -- 商家應收淨額
    (TotalAmount - Service_fee - AbnormalAmount) AS FinalAmount,  -- 扣除異常後金額
    -- 判斷處理方式
    CASE
        WHEN (TotalAmount - Service_fee - AbnormalAmount) > 0 THEN '正數-下次扣除'
        WHEN (TotalAmount - Service_fee - AbnormalAmount) = 0 THEN '歸零-不處理'
        WHEN (TotalAmount - Service_fee - AbnormalAmount) < 0 THEN '負數-寫欠費'
    END AS 處理方式,
    -- 如果是負數,這就是欠費金額
    CASE
        WHEN (TotalAmount - Service_fee - AbnormalAmount) < 0
        THEN (TotalAmount - Service_fee - AbnormalAmount)
        ELSE 0
    END AS 欠費金額
FROM MerchantSummary
ORDER BY FinalAmount ASC;
```

### 步驟 2: 建立 Grant_History 欠費記錄 (僅針對 d < 0 的商家)

```sql
-- ========================================
-- 寫入 Grant_History 欠費記錄
-- ========================================
WITH MerchantDebt AS (
    SELECT
        oa.user_account,
        oa.sonid,
        bm.mem_Branchwebname AS MerchantName,
        bm.bank_code,
        bm.bank_branch_code,
        bm.bank_account,
        bm.account_name,
        bm.bankname,
        SUM(oa.TotalAmount) AS TotalAmount,
        SUM(oa.Service_fee) AS Service_fee,
        (
            SELECT ISNULL(SUM(oi2.TotalAmount), 0)
            FROM Order_Accounting oa2
            INNER JOIN Order_Info oi2
                ON oa2.LogisticNumber = oi2.LogisticNumber
                AND oa2.sno = oi2.sno
            WHERE oa2.GrantdaisouDate > '2025-10-15 00:00:00'
                AND oa2.user_account = oa.user_account
                AND oa2.sonid = oa.sonid
                AND oi2.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
        ) AS AbnormalAmount,
        GETDATE() AS GrantDate
    FROM Order_Accounting oa
    INNER JOIN Branch_Member bm
        ON oa.user_account = bm.user_account
        AND oa.sonid = bm.sonid
    WHERE oa.GrantdaisouDate > '2025-10-15 00:00:00'
        AND oa.DeliverMode = '01'
    GROUP BY
        oa.user_account,
        oa.sonid,
        bm.mem_Branchwebname,
        bm.bank_code,
        bm.bank_branch_code,
        bm.bank_account,
        bm.account_name,
        bm.bankname
    HAVING (SUM(oa.TotalAmount) - SUM(oa.Service_fee) -
            (
                SELECT ISNULL(SUM(oi2.TotalAmount), 0)
                FROM Order_Accounting oa2
                INNER JOIN Order_Info oi2
                    ON oa2.LogisticNumber = oi2.LogisticNumber
                    AND oa2.sno = oi2.sno
                WHERE oa2.GrantdaisouDate > '2025-10-15 00:00:00'
                    AND oa2.user_account = oa.user_account
                    AND oa2.sonid = oa.sonid
                    AND oi2.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
            )) < 0  -- 只處理負數(欠費)的商家
)
INSERT INTO Grant_History (
    bank_account,
    bank_code,
    bank_branch_code,
    user_account,
    account_name,
    bankname,
    GrantTotalAmount,  -- 負數
    Excel_Name,
    Grant_txtName,
    Grantdate,
    TotalServicefee,
    BulkGrantTotalAmount,
    SettledAmount,
    grant_type
)
SELECT
    bank_account,
    bank_code,
    bank_branch_code,
    user_account,
    account_name,
    bankname,
    -- GrantTotalAmount = 負數欠費金額
    (TotalAmount - Service_fee - AbnormalAmount) AS GrantTotalAmount,
    '誤撥退貨補救_' + CONVERT(VARCHAR(10), GETDATE(), 112) AS Excel_Name,  -- 例: 誤撥退貨補救_20251017
    '' AS Grant_txtName,  -- 空值,因為沒有實際撥款檔
    CAST(GETDATE() AS DATE) AS Grantdate,
    Service_fee AS TotalServicefee,
    0 AS BulkGrantTotalAmount,
    0 AS SettledAmount,
    1 AS grant_type  -- 1 = C2C
FROM MerchantDebt;

-- 查看插入結果
SELECT @@ROWCOUNT AS '寫入欠費記錄筆數';
```

### 步驟 3: 建立補償記錄 (針對 d >= 0 的商家,下次撥款扣除)

```sql
-- ========================================
-- 建立補償記錄 (d >= 0 的商家,不寫欠費,改用補償機制)
-- ========================================
IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Grant_Compensation')
BEGIN
    -- 請參考之前的「退貨訂單誤撥代收款_實際執行方案.md」中的建表SQL
    PRINT '請先建立 Grant_Compensation 表';
END
ELSE
BEGIN
    WITH MerchantComp AS (
        SELECT
            oa.user_account,
            oa.sonid,
            bm.bank_code,
            bm.bank_branch_code,
            bm.bank_account,
            bm.account_name,
            SUM(oa.TotalAmount) AS TotalAmount,
            SUM(oa.Service_fee) AS Service_fee,
            (
                SELECT ISNULL(SUM(oi2.TotalAmount), 0)
                FROM Order_Accounting oa2
                INNER JOIN Order_Info oi2
                    ON oa2.LogisticNumber = oi2.LogisticNumber
                    AND oa2.sno = oi2.sno
                WHERE oa2.GrantdaisouDate > '2025-10-15 00:00:00'
                    AND oa2.user_account = oa.user_account
                    AND oa2.sonid = oa.sonid
                    AND oi2.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
            ) AS AbnormalAmount
        FROM Order_Accounting oa
        INNER JOIN Branch_Member bm
            ON oa.user_account = bm.user_account
            AND oa.sonid = bm.sonid
        WHERE oa.GrantdaisouDate > '2025-10-15 00:00:00'
            AND oa.DeliverMode = '01'
        GROUP BY
            oa.user_account,
            oa.sonid,
            bm.bank_code,
            bm.bank_branch_code,
            bm.bank_account,
            bm.account_name
        HAVING (SUM(oa.TotalAmount) - SUM(oa.Service_fee) -
                (
                    SELECT ISNULL(SUM(oi2.TotalAmount), 0)
                    FROM Order_Accounting oa2
                    INNER JOIN Order_Info oi2
                        ON oa2.LogisticNumber = oi2.LogisticNumber
                        AND oa2.sno = oi2.sno
                    WHERE oa2.GrantdaisouDate > '2025-10-15 00:00:00'
                        AND oa2.user_account = oa.user_account
                        AND oa2.sonid = oa.sonid
                        AND oi2.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
                )) >= 0  -- 只處理 >= 0 的商家
    )
    -- 插入異常訂單的明細到 Grant_Compensation
    INSERT INTO Grant_Compensation (
        LogisticNumber,
        sno,
        user_account,
        sonid,
        Logistic_service,
        OrderNo,
        OriginalGrantDate,
        CompensationType,
        AbnormalStatus,
        CompensationAmount,  -- 負數
        TotalAmount,
        Service_fee,
        cost,
        Status,
        Remark,
        CreateDate
    )
    SELECT
        oa.LogisticNumber,
        oa.sno,
        oa.user_account,
        oa.sonid,
        oa.Logistic_service,
        oa.OrderNo,
        oa.GrantdaisouDate AS OriginalGrantDate,
        -- 判斷補償類型
        CASE
            WHEN oi.Detail_Status_Description LIKE '%退貨%' THEN '退貨誤撥'
            WHEN oi.Detail_Status_Description LIKE '%取消%' THEN '取消誤撥'
            WHEN oi.Detail_Status_Description LIKE '%逾期%' THEN '逾期誤撥'
            WHEN oi.Detail_Status_Description LIKE '%拒收%' THEN '拒收誤撥'
            ELSE '其他異常誤撥'
        END AS CompensationType,
        oi.Detail_Status_Description AS AbnormalStatus,
        -- 補償金額 = -(代收款 - 服務費),負數表示要扣回
        -(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS CompensationAmount,
        oa.TotalAmount,
        oa.Service_fee,
        oa.cost,
        'Pending' AS Status,
        '誤撥退貨訂單補救-下次撥款扣除' AS Remark,
        GETDATE()
    FROM Order_Accounting oa
    INNER JOIN Order_Info oi
        ON oa.LogisticNumber = oi.LogisticNumber
        AND oa.sno = oi.sno
    WHERE oa.GrantdaisouDate > '2025-10-15 00:00:00'
        AND oa.DeliverMode = '01'
        AND oi.Detail_Status_Description NOT IN ('買家已取件', '消費者成功取件')
        -- 只處理商家結果 >= 0 的訂單
        AND EXISTS (
            SELECT 1 FROM MerchantComp mc
            WHERE mc.user_account = oa.user_account
                AND mc.sonid = oa.sonid
        )
        -- 避免重複插入
        AND NOT EXISTS (
            SELECT 1 FROM Grant_Compensation gc
            WHERE gc.LogisticNumber = oa.LogisticNumber
                AND gc.sno = oa.sno
                AND gc.OriginalGrantDate = oa.GrantdaisouDate
        );

    -- 查看插入結果
    SELECT @@ROWCOUNT AS '插入補償記錄筆數';
END
```

---

## 📊 驗證與追蹤

### 查詢欠費寫入結果

```sql
-- ========================================
-- 查詢寫入 Grant_History 的欠費記錄
-- ========================================
SELECT
    gh.user_account,
    bm.mem_Branchwebname AS MerchantName,
    gh.bank_code,
    gh.bank_account,
    gh.account_name,
    gh.GrantTotalAmount AS 欠費金額,  -- 負數
    gh.TotalServicefee AS 服務費,
    gh.Excel_Name,
    gh.Grantdate AS 欠費日,
    gh.Grant_txtName AS 撥款檔名,
    CASE
        WHEN gh.Grant_txtName IS NULL OR gh.Grant_txtName = '' THEN '未結算'
        ELSE '已結算'
    END AS 結算狀態
FROM Grant_History gh
INNER JOIN Branch_Member bm
    ON gh.user_account = bm.user_account
WHERE gh.Excel_Name LIKE '誤撥退貨補救%'
ORDER BY gh.GrantTotalAmount ASC;
```

### 查詢補償記錄結果

```sql
-- ========================================
-- 查詢補償記錄(d >= 0 的商家)
-- ========================================
SELECT
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS MerchantName,
    gc.CompensationType AS 補償類型,
    COUNT(*) AS 訂單數,
    SUM(gc.CompensationAmount) AS 補償金額,  -- 負數
    gc.Status AS 狀態
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
WHERE gc.Remark LIKE '%誤撥退貨訂單補救%'
GROUP BY
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname,
    gc.CompensationType,
    gc.Status
ORDER BY 補償金額 ASC;
```

### 總覽報表

```sql
-- ========================================
-- 總覽:誤撥補救處理統計
-- ========================================
WITH AllMerchants AS (
    -- 所有受影響的商家
    SELECT DISTINCT
        oa.user_account,
        oa.sonid,
        bm.mem_Branchwebname AS MerchantName
    FROM Order_Accounting oa
    INNER JOIN Branch_Member bm
        ON oa.user_account = bm.user_account
        AND oa.sonid = bm.sonid
    WHERE oa.GrantdaisouDate > '2025-10-15 00:00:00'
        AND oa.DeliverMode = '01'
),
DebtMerchants AS (
    -- 寫入欠費的商家
    SELECT
        user_account,
        SUM(GrantTotalAmount) AS DebtAmount
    FROM Grant_History
    WHERE Excel_Name LIKE '誤撥退貨補救%'
    GROUP BY user_account
),
CompMerchants AS (
    -- 寫入補償的商家
    SELECT
        user_account,
        sonid,
        SUM(CompensationAmount) AS CompAmount
    FROM Grant_Compensation
    WHERE Remark LIKE '%誤撥退貨訂單補救%'
    GROUP BY user_account, sonid
)
SELECT
    am.user_account,
    am.MerchantName,
    CASE
        WHEN dm.user_account IS NOT NULL THEN '寫欠費'
        WHEN cm.user_account IS NOT NULL THEN '補償扣除'
        ELSE '未處理'
    END AS 處理方式,
    ISNULL(dm.DebtAmount, 0) AS 欠費金額,
    ISNULL(cm.CompAmount, 0) AS 補償金額
FROM AllMerchants am
LEFT JOIN DebtMerchants dm
    ON am.user_account = dm.user_account
LEFT JOIN CompMerchants cm
    ON am.user_account = cm.user_account
    AND am.sonid = cm.sonid
ORDER BY am.user_account;
```

---

## 🔄 結算扣額度處理

### 是否需要手動扣額度?

**答**: **不需要**

**原因**:
1. **寫欠費的商家** (d < 0):
   - 欠費記錄寫入 `Grant_History`
   - 下次撥款時,系統會自動從撥款扣除欠費 (OrderController.cs 第 1388-1414 行)
   - 扣除時會自動執行 `QuotaChangeEnum.DeductNegativeQuotaSettlement` (第 1646 行)
   - **系統會自動處理額度扣除**

2. **補償扣除的商家** (d >= 0):
   - 補償記錄寫入 `Grant_Compensation`
   - 下次撥款時從撥款扣除補償金額
   - 扣除時會執行 `QuotaChangeEnum.DeductQuotaSettlement` (第 1624 行)
   - **系統也會自動處理額度扣除**

### 特殊情況:如果需要立即扣額度

如果商家短期內不會有撥款,但公司希望立即扣除額度,可以執行:

```sql
-- ========================================
-- 手動扣除商家額度 (謹慎使用!)
-- ========================================
-- 僅供參考,實際執行請由業務和財務確認

-- 查詢需要扣額度的商家
SELECT
    gh.user_account,
    bm.mem_Branchwebname AS MerchantName,
    gh.GrantTotalAmount AS 欠費金額,
    bm.mem_Qutoa AS 目前額度,
    bm.mem_Qutoa + gh.GrantTotalAmount AS 扣除後額度  -- 欠費是負數,所以是相減
FROM Grant_History gh
INNER JOIN Branch_Member bm
    ON gh.user_account = bm.user_account
WHERE gh.Excel_Name LIKE '誤撥退貨補救%'
    AND (gh.Grant_txtName IS NULL OR gh.Grant_txtName = '')  -- 未結算的
ORDER BY gh.GrantTotalAmount ASC;

-- 執行扣額度 (需要呼叫 Up_memQuotaAndAddHistory 方法)
-- 建議透過程式執行,不要直接 UPDATE Branch_Member
```

---

## ✅ 執行檢查清單

### 執行前

- [ ] 備份 `Grant_History`, `Grant_Compensation`, `Branch_Member` 表
- [ ] 在測試環境執行所有 SQL,驗證邏輯正確
- [ ] 確認受影響的14個商家帳號無誤
- [ ] 人工核對「欠費商家」和「補償商家」的金額

### 執行步驟

1. [ ] 執行步驟1查詢,匯出商家處理清單
2. [ ] 執行步驟2,寫入 Grant_History 欠費記錄 (d < 0 的商家)
3. [ ] 執行步驟3,寫入 Grant_Compensation 補償記錄 (d >= 0 的商家)
4. [ ] 執行驗證查詢,確認寫入正確
5. [ ] 產生報表給財務和業務單位確認

### 執行後

- [ ] 監控下次撥款時,欠費和補償是否正確扣除
- [ ] 檢查額度變動記錄
- [ ] 更新操作文件和 SOP

---

## 📌 重要提醒

1. **欠費vs補償的選擇**:
   - `d < 0`: 寫 `Grant_History` 欠費
   - `d >= 0`: 寫 `Grant_Compensation` 補償
   - 兩者邏輯不同,不可混用

2. **額度扣除時機**:
   - 寫欠費: 下次撥款時自動扣
   - 寫補償: 下次撥款時自動扣
   - **都是自動處理,不需要手動扣額度**

3. **撥款檔名 (Grant_txtName)**:
   - 欠費記錄: 初始為空
   - 下次撥款扣除時,會更新為實際的撥款檔名
   - 更新後表示「已結算」

4. **避免重複寫入**:
   - SQL 中已加入 `NOT EXISTS` 檢查
   - 執行前先查詢是否已存在記錄

5. **與現有系統整合**:
   - 此方案完全相容現有的撥款流程
   - 不需要修改 OrderController 的撥款邏輯
   - 只需要正確寫入 `Grant_History` 或 `Grant_Compensation`
