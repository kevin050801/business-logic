# 退貨訂單誤撥代收款 - 補救方案

## 問題概述

**發現問題**:
- 昨天執行「補壓代收請款日」操作後,發現有些訂單雖然 `ReconciliationResult='Y'` (核帳結果為Y)
- 但這些訂單實際上是**退貨訂單**,不該撥代收款給商家
- 系統已經誤撥款給商家,需要補救

**影響範圍**:
- 時間範圍:10/1、10/8 兩次撥款日
- 涉及物流服務:C2C交貨便、大宗快撥、7-11冷凍C2C(21)

---

## 步驟 1:查詢被誤撥的退貨訂單

### 1-1. 判斷退貨訂單的條件

退貨訂單在 `LogisticProcessHistory` 中會有特定的 respcode,需要先確認系統中的退貨狀態碼:

```sql
-- ========================================
-- 查詢系統中的退貨相關狀態碼
-- ========================================
SELECT DISTINCT
    respcode,
    COUNT(*) as OrderCount
FROM LogisticProcessHistory
WHERE respcode LIKE '20%'  -- 退貨相關狀態碼通常是 20xx
    OR respcode LIKE '3%'   -- 取消相關狀態碼
    OR Detail_Status_Description LIKE '%退貨%'
GROUP BY respcode
ORDER BY respcode;
```

**預期的退貨狀態碼** (需要實際查詢確認):
- `2063` - 退貨門市驗收
- `2073` - 已退貨
- `3000` - 已取消
- 其他可能的退貨狀態碼

### 1-2. 查詢被誤撥的退貨訂單 (一般C2C + 大宗快撥)

```sql
-- ========================================
-- 查詢被誤撥代收款的退貨訂單 (10/1 + 10/8)
-- ========================================
SELECT
    oa.LogisticNumber,
    oa.sno,
    oa.user_account,
    oa.sonid,
    oa.Logistic_service,
    oa.TotalAmount,
    oa.Service_fee,
    oa.cost,
    oa.CheckoutdaisouDate,
    oa.GrantdaisouDate,
    bm.mem_Branchwebname AS MerchantName,
    CASE
        WHEN oa.Logistic_service IN ('01','03','05','10','23') THEN 'C2C交貨便'
        WHEN oa.Logistic_service IN ('02','04','22','24') AND oa.advance_Granted = '1' THEN '大宗快撥'
        ELSE '其他'
    END AS ServiceType,
    lph.respcode AS ReturnRespCode,
    lph.Detail_Status_Description AS ReturnStatus
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
INNER JOIN (
    -- 找出有退貨記錄的訂單
    SELECT DISTINCT
        CAST(LogisticNumber AS VARCHAR) AS LogisticNumber,
        CAST(paymentno AS VARCHAR) AS paymentno,
        respcode,
        Detail_Status_Description
    FROM LogisticProcessHistory
    WHERE (
        respcode IN ('2063', '2073', '3000')  -- 請根據實際退貨狀態碼調整
        OR Detail_Status_Description LIKE '%退貨%'
        OR Detail_Status_Description LIKE '%取消%'
    )
) lph
    ON oa.LogisticNumber = lph.LogisticNumber
    AND oa.paymentno = lph.paymentno
WHERE (
    -- 10/1 或 10/8 撥款
    oa.CheckoutdaisouDate IN ('2025-10-01', '2025-10-08')
    OR oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08')
)
AND (
    -- C2C 交貨便/店到店
    oa.Logistic_service IN ('01','03','05','10','23')
    OR
    -- 大宗快撥
    (oa.Logistic_service IN ('02','04','22','24') AND oa.advance_Granted = '1')
)
AND oa.DeliverMode = '01'
AND oa.Checkoutable = '1'
AND oi.ReconciliationResult = 'Y'
ORDER BY oa.CheckoutdaisouDate, oa.user_account, oa.Logistic_service;
```

### 1-3. 查詢被誤撥的退貨訂單 (21 - 7-11冷凍C2C)

```sql
-- ========================================
-- 查詢被誤撥代收款的退貨訂單 - 21服務 (10/1 + 10/8)
-- ========================================
SELECT
    oa.LogisticNumber,
    oa.sno,
    oa.user_account,
    oa.sonid,
    oa.Logistic_service,
    oa.TotalAmount,
    oa.Service_fee,
    oa.cost,
    oa.CheckoutdaisouDate,
    oa.GrantdaisouDate,
    bm.mem_Branchwebname AS MerchantName,
    lph.respcode AS ReturnRespCode,
    lph.Detail_Status_Description AS ReturnStatus
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN Branch_Member bm
    ON oa.user_account = bm.user_account
    AND oa.sonid = bm.sonid
INNER JOIN (
    -- 找出有退貨記錄的訂單
    SELECT DISTINCT
        CAST(LogisticNumber AS VARCHAR) AS LogisticNumber,
        CAST(paymentno AS VARCHAR) AS paymentno,
        respcode,
        Detail_Status_Description
    FROM LogisticProcessHistory
    WHERE (
        respcode IN ('2063', '2073', '3000')  -- 請根據實際退貨狀態碼調整
        OR Detail_Status_Description LIKE '%退貨%'
        OR Detail_Status_Description LIKE '%取消%'
    )
    AND LogisticServiceID = '21'
    AND FileTitle = 'NPPS'
) lph
    ON oa.LogisticNumber = lph.LogisticNumber
    AND oa.paymentno = lph.paymentno
WHERE (
    -- 10/1 或 10/8 撥款
    oa.CheckoutdaisouDate IN ('2025-10-01', '2025-10-08')
    OR oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08')
)
AND oa.Logistic_service = '21'
AND oa.DeliverMode = '01'
AND oa.Checkoutable = '1'
AND oi.ReconciliationResult = 'Y'
ORDER BY oa.CheckoutdaisouDate, oa.user_account;
```

### 1-4. 統計誤撥金額 (按商家彙總)

```sql
-- ========================================
-- 統計每個商家被誤撥的總金額
-- ========================================
WITH ReturnOrders AS (
    -- 所有被誤撥的退貨訂單 (包含一般C2C + 大宗快撥 + 21服務)
    SELECT
        oa.LogisticNumber,
        oa.user_account,
        oa.sonid,
        oa.Logistic_service,
        oa.TotalAmount,
        oa.Service_fee,
        oa.cost,
        oa.CheckoutdaisouDate,
        oa.GrantdaisouDate
    FROM Order_Accounting oa
    INNER JOIN Order_Info oi
        ON oa.LogisticNumber = oi.LogisticNumber
        AND oa.sno = oi.sno
    INNER JOIN (
        SELECT DISTINCT
            CAST(LogisticNumber AS VARCHAR) AS LogisticNumber,
            CAST(paymentno AS VARCHAR) AS paymentno
        FROM LogisticProcessHistory
        WHERE (
            respcode IN ('2063', '2073', '3000')  -- 請根據實際退貨狀態碼調整
            OR Detail_Status_Description LIKE '%退貨%'
            OR Detail_Status_Description LIKE '%取消%'
        )
    ) lph
        ON oa.LogisticNumber = lph.LogisticNumber
        AND oa.paymentno = lph.paymentno
    WHERE (
        oa.CheckoutdaisouDate IN ('2025-10-01', '2025-10-08')
        OR oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08')
    )
    AND (
        oa.Logistic_service IN ('01','03','05','10','21','23')
        OR (oa.Logistic_service IN ('02','04','22','24') AND oa.advance_Granted = '1')
    )
    AND oa.DeliverMode = '01'
    AND oa.Checkoutable = '1'
    AND oi.ReconciliationResult = 'Y'
)
SELECT
    ro.user_account,
    ro.sonid,
    bm.mem_Branchwebname AS MerchantName,
    bm.bank_code,
    bm.bank_account,
    bm.account_name,
    COUNT(*) AS 誤撥訂單數,
    SUM(ro.TotalAmount) AS 誤撥代收款總額,
    SUM(ro.Service_fee) AS 商家應付服務費總額,
    SUM(ro.cost) AS PayNow成本總額,
    SUM(ro.TotalAmount) - SUM(ro.Service_fee) AS 商家實收淨額,
    -- 商家需要補償的金額 = 誤撥的代收款 - 本來就該收的服務費
    SUM(ro.TotalAmount) - SUM(ro.Service_fee) AS 商家需補償金額
FROM ReturnOrders ro
INNER JOIN Branch_Member bm
    ON ro.user_account = bm.user_account
    AND ro.sonid = bm.sonid
GROUP BY
    ro.user_account,
    ro.sonid,
    bm.mem_Branchwebname,
    bm.bank_code,
    bm.bank_account,
    bm.account_name
ORDER BY 商家需補償金額 DESC;
```

---

## 步驟 2:補救方案規劃

### 方案 A:直接回扣代收款 (推薦)

**概念**:
1. 不更動已經執行的撥款記錄
2. 建立「補償帳務」記錄這次的誤撥
3. 在下次撥款時,從商家應撥款項中扣除誤撥金額

**優點**:
- ✅ 不影響已有的帳務記錄和報表
- ✅ 有完整的補償軌跡可追蹤
- ✅ 不需要真的退款,直接從下次撥款扣除

**缺點**:
- ⚠️ 需要確保商家下次撥款金額足夠扣除
- ⚠️ 如果商家長期沒有訂單,會產生「掛帳」

### 方案 B:撤銷撥款記錄 (不推薦)

**概念**:
1. 將誤撥訂單的 `GrantdaisouDate` 設為 NULL
2. 修改 `Grant_History` 相關記錄

**優點**:
- ✅ 邏輯直觀,就像沒發生過

**缺點**:
- ❌ 破壞帳務完整性
- ❌ 已經匯款的金額無法撤回
- ❌ 報表會不一致

---

## 步驟 3:執行補救 (方案A - 建立補償記錄)

### 3-1. 建立補償記錄表 (如果不存在)

```sql
-- ========================================
-- 建立補償記錄表
-- ========================================
IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Grant_Compensation')
BEGIN
    CREATE TABLE Grant_Compensation (
        CompensationID INT IDENTITY(1,1) PRIMARY KEY,
        LogisticNumber VARCHAR(50) NOT NULL,
        sno INT NOT NULL,
        user_account VARCHAR(50) NOT NULL,
        sonid VARCHAR(50) NOT NULL,
        Logistic_service VARCHAR(10),
        OriginalGrantDate DATE,  -- 原本的撥款日
        CompensationType VARCHAR(20),  -- 補償類型:'退貨誤撥'
        CompensationAmount DECIMAL(18,2),  -- 需要補償的金額 (負數表示要扣款)
        TotalAmount INT,  -- 原代收款金額
        Service_fee DECIMAL(18,2),  -- 服務費
        cost DECIMAL(18,2),  -- 成本
        DeductedGrantDate DATE NULL,  -- 實際扣款日期
        DeductedAmount DECIMAL(18,2) NULL,  -- 實際扣款金額
        Status VARCHAR(20) DEFAULT 'Pending',  -- 狀態:'Pending'/'Deducted'/'Cancelled'
        Remark NVARCHAR(500),  -- 備註
        CreateDate DATETIME DEFAULT GETDATE(),
        UpdateDate DATETIME,
        FOREIGN KEY (LogisticNumber, sno) REFERENCES Order_Accounting(LogisticNumber, sno)
    );

    CREATE INDEX IX_Grant_Compensation_UserAccount
        ON Grant_Compensation(user_account, sonid, Status);
    CREATE INDEX IX_Grant_Compensation_GrantDate
        ON Grant_Compensation(OriginalGrantDate);
END
```

### 3-2. 插入退貨誤撥的補償記錄

```sql
-- ========================================
-- 插入退貨訂單的補償記錄
-- ========================================
INSERT INTO Grant_Compensation (
    LogisticNumber,
    sno,
    user_account,
    sonid,
    Logistic_service,
    OriginalGrantDate,
    CompensationType,
    CompensationAmount,
    TotalAmount,
    Service_fee,
    cost,
    Status,
    Remark,
    CreateDate
)
SELECT
    oa.LogisticNumber,
    oa.sno,
    oa.user_account,
    oa.sonid,
    oa.Logistic_service,
    -- 以 GrantdaisouDate 為準,如果沒有則用 CheckoutdaisouDate
    COALESCE(oa.GrantdaisouDate, oa.CheckoutdaisouDate) AS OriginalGrantDate,
    '退貨誤撥' AS CompensationType,
    -- 補償金額 = -(代收款 - 服務費),負數表示要從商家扣回
    -(oa.TotalAmount - ISNULL(oa.Service_fee, 0)) AS CompensationAmount,
    oa.TotalAmount,
    oa.Service_fee,
    oa.cost,
    'Pending' AS Status,
    '10/1、10/8 補壓代收請款日時誤撥退貨訂單,需回扣代收款' AS Remark,
    GETDATE()
FROM Order_Accounting oa
INNER JOIN Order_Info oi
    ON oa.LogisticNumber = oi.LogisticNumber
    AND oa.sno = oi.sno
INNER JOIN (
    -- 找出有退貨記錄的訂單
    SELECT DISTINCT
        CAST(LogisticNumber AS VARCHAR) AS LogisticNumber,
        CAST(paymentno AS VARCHAR) AS paymentno
    FROM LogisticProcessHistory
    WHERE (
        respcode IN ('2063', '2073', '3000')  -- 請根據實際退貨狀態碼調整
        OR Detail_Status_Description LIKE '%退貨%'
        OR Detail_Status_Description LIKE '%取消%'
    )
) lph
    ON oa.LogisticNumber = lph.LogisticNumber
    AND oa.paymentno = lph.paymentno
WHERE (
    oa.CheckoutdaisouDate IN ('2025-10-01', '2025-10-08')
    OR oa.GrantdaisouDate IN ('2025-10-01', '2025-10-08')
)
AND (
    oa.Logistic_service IN ('01','03','05','10','21','23')
    OR (oa.Logistic_service IN ('02','04','22','24') AND oa.advance_Granted = '1')
)
AND oa.DeliverMode = '01'
AND oa.Checkoutable = '1'
AND oi.ReconciliationResult = 'Y'
-- 避免重複插入
AND NOT EXISTS (
    SELECT 1 FROM Grant_Compensation gc
    WHERE gc.LogisticNumber = oa.LogisticNumber
        AND gc.sno = oa.sno
        AND gc.CompensationType = '退貨誤撥'
);

-- 查看插入結果
SELECT @@ROWCOUNT AS '插入補償記錄筆數';
```

### 3-3. 查詢各商家需補償的總金額

```sql
-- ========================================
-- 查詢各商家需補償的總金額
-- ========================================
SELECT
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS MerchantName,
    COUNT(*) AS 誤撥訂單數,
    SUM(gc.CompensationAmount) AS 需回扣總金額,  -- 負數
    SUM(gc.TotalAmount) AS 原代收款總額,
    SUM(gc.Service_fee) AS 服務費總額,
    gc.Status AS 補償狀態
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
WHERE gc.CompensationType = '退貨誤撥'
    AND gc.Status = 'Pending'
GROUP BY
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname,
    gc.Status
ORDER BY 需回扣總金額 ASC;  -- 負數由小到大
```

---

## 步驟 4:修改撥款程式自動扣除

### 4-1. 修改 `Grant_AndC2CReport` 方法

在 `OrderController.cs` 的 `Grant_AndC2CReport` 方法中,需要加入以下邏輯:

**修改位置**: `D:\1. rep\PayNowLogistics\PayNowLogistics\Areas\Administrator\Controllers\OrderController.cs` 第 799 行之後

**新增邏輯**:
```csharp
// ========================================
// 新增:檢查商家是否有待扣除的補償金額
// ========================================
public Dictionary<string, decimal> GetPendingCompensationAmounts(List<string> userAccounts)
{
    Dictionary<string, decimal> compensationDict = new Dictionary<string, decimal>();

    using (SqlConnection conn = new SqlConnection(connStr))
    {
        string sql = @"
            SELECT
                user_account + '_' + sonid AS AccountKey,
                SUM(CompensationAmount) AS TotalCompensation
            FROM Grant_Compensation
            WHERE Status = 'Pending'
                AND user_account IN @UserAccounts
            GROUP BY user_account, sonid
        ";

        using (SqlCommand cmd = new SqlCommand(sql, conn))
        {
            conn.Open();
            // 加入參數 (需要轉換成 DataTable 或逐個加入)
            // ... 實作細節

            using (SqlDataReader reader = cmd.ExecuteReader())
            {
                while (reader.Read())
                {
                    string key = reader["AccountKey"].ToString();
                    decimal amount = Convert.ToDecimal(reader["TotalCompensation"]);
                    compensationDict[key] = amount;
                }
            }
        }
    }

    return compensationDict;
}
```

**在撥款計算時扣除**:
```csharp
// 原本的撥款金額計算
decimal grantAmount = totalAmount - serviceFee;

// 檢查是否有待扣除的補償金額
string accountKey = $"{userAccount}_{sonid}";
if (compensationDict.ContainsKey(accountKey))
{
    decimal compensation = compensationDict[accountKey];
    grantAmount += compensation;  // compensation 是負數,所以用加法

    // 記錄此次扣除
    UpdateCompensationStatus(userAccount, sonid, GrantDate, compensation);
}

// 繼續原本的撥款邏輯...
```

### 4-2. 建立 Stored Procedure 處理補償扣除

```sql
-- ========================================
-- 建立 SP:處理撥款時的補償扣除
-- ========================================
CREATE PROCEDURE SP_ProcessGrantCompensation
    @user_account VARCHAR(50),
    @sonid VARCHAR(50),
    @GrantDate DATE,
    @MaxDeductAmount DECIMAL(18,2)  -- 本次最多可扣除的金額
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @TotalCompensation DECIMAL(18,2);
    DECLARE @ActualDeducted DECIMAL(18,2);

    -- 查詢待扣除的補償總額
    SELECT @TotalCompensation = SUM(CompensationAmount)
    FROM Grant_Compensation
    WHERE user_account = @user_account
        AND sonid = @sonid
        AND Status = 'Pending';

    -- 如果沒有待扣除的補償,直接返回
    IF @TotalCompensation IS NULL OR @TotalCompensation = 0
    BEGIN
        SELECT 0 AS DeductedAmount, 0 AS RemainingCompensation;
        RETURN;
    END

    -- 計算實際可扣除的金額 (不能超過本次撥款金額)
    -- TotalCompensation 是負數,表示要扣除
    IF ABS(@TotalCompensation) <= @MaxDeductAmount
    BEGIN
        -- 可以全部扣除
        SET @ActualDeducted = @TotalCompensation;

        -- 更新所有待扣除的補償記錄
        UPDATE Grant_Compensation
        SET Status = 'Deducted',
            DeductedGrantDate = @GrantDate,
            DeductedAmount = CompensationAmount,
            UpdateDate = GETDATE()
        WHERE user_account = @user_account
            AND sonid = @sonid
            AND Status = 'Pending';
    END
    ELSE
    BEGIN
        -- 本次撥款金額不足以扣除全部補償
        -- 部分扣除 (FIFO:先進先出)
        SET @ActualDeducted = -@MaxDeductAmount;

        -- 這裡需要更複雜的邏輯處理部分扣除
        -- 建議:記錄為部分扣除,剩餘金額留到下次
        -- 實作細節需要根據實際業務需求調整
    END

    -- 返回扣除結果
    SELECT
        @ActualDeducted AS DeductedAmount,
        @TotalCompensation - @ActualDeducted AS RemainingCompensation;
END
GO
```

---

## 步驟 5:建立補償報表

### 5-1. 查詢補償執行狀況

```sql
-- ========================================
-- 查詢補償執行狀況
-- ========================================
SELECT
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS MerchantName,
    gc.Status,
    COUNT(*) AS 訂單數,
    SUM(gc.CompensationAmount) AS 補償金額,
    SUM(gc.DeductedAmount) AS 已扣除金額,
    SUM(gc.CompensationAmount) - ISNULL(SUM(gc.DeductedAmount), 0) AS 待扣除金額,
    MIN(gc.CreateDate) AS 建立時間,
    MAX(gc.DeductedGrantDate) AS 最後扣除日期
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
WHERE gc.CompensationType = '退貨誤撥'
GROUP BY
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname,
    gc.Status
ORDER BY gc.Status, 待扣除金額 ASC;
```

### 5-2. 匯出完整補償明細

```sql
-- ========================================
-- 匯出完整補償明細 (供對帳用)
-- ========================================
SELECT
    gc.CompensationID,
    gc.LogisticNumber,
    gc.user_account,
    gc.sonid,
    bm.mem_Branchwebname AS MerchantName,
    gc.Logistic_service,
    gc.OriginalGrantDate AS 原撥款日,
    gc.TotalAmount AS 代收款,
    gc.Service_fee AS 服務費,
    gc.cost AS 成本,
    gc.CompensationAmount AS 需補償金額,
    gc.DeductedGrantDate AS 扣款日期,
    gc.DeductedAmount AS 實扣金額,
    gc.Status AS 狀態,
    gc.Remark AS 備註,
    gc.CreateDate AS 建立時間
FROM Grant_Compensation gc
INNER JOIN Branch_Member bm
    ON gc.user_account = bm.user_account
    AND gc.sonid = bm.sonid
WHERE gc.CompensationType = '退貨誤撥'
ORDER BY gc.CreateDate, gc.user_account;
```

---

## 步驟 6:通知受影響商家

### 通知內容範本

```
主旨:PayNow物流系統 - 代收款調整通知

親愛的商家您好:

因系統處理作業,以下訂單於撥款時有誤撥代收款的情況:

- 影響訂單數: {XX} 筆
- 誤撥金額: NT$ {XXX,XXX}
- 原撥款日期: 2025-10-01 / 2025-10-08

這些訂單為退貨訂單,依照合約規定不撥付代收款,將於下次撥款時扣除誤撥金額。

如有任何疑問,請聯繫客服團隊。

PayNow物流團隊 敬上
```

---

## 步驟 7:預防措施 (避免再次發生)

### 7-1. 修改 `WeeklySettlement` 排程

在壓代收請款日時,加入退貨訂單的檢查:

```sql
-- 在壓 CheckoutdaisouDate 時,排除退貨訂單
AND NOT EXISTS (
    SELECT 1
    FROM LogisticProcessHistory lph
    WHERE lph.LogisticNumber = oa.LogisticNumber
        AND lph.paymentno = oa.paymentno
        AND (
            lph.respcode IN ('2063', '2073', '3000')  -- 退貨狀態碼
            OR lph.Detail_Status_Description LIKE '%退貨%'
            OR lph.Detail_Status_Description LIKE '%取消%'
        )
)
```

### 7-2. 修改 `Grant_AndC2CReport` 撥款邏輯

在撥款時,再次檢查是否為退貨訂單:

```csharp
// 在查詢要撥款的訂單時,排除退貨訂單
sqlstr += @"
AND NOT EXISTS (
    SELECT 1
    FROM LogisticProcessHistory lph
    WHERE lph.LogisticNumber = Order_Accounting.LogisticNumber
        AND lph.paymentno = Order_Accounting.paymentno
        AND (
            lph.respcode IN ('2063', '2073', '3000')
            OR lph.Detail_Status_Description LIKE '%退貨%'
            OR lph.Detail_Status_Description LIKE '%取消%'
        )
)
";
```

---

## 總結

### 執行順序

1. ✅ **步驟 1**: 查詢被誤撥的退貨訂單,確認影響範圍
2. ✅ **步驟 2**: 選擇補救方案 (推薦方案A)
3. ✅ **步驟 3**: 建立補償記錄表,插入誤撥記錄
4. ✅ **步驟 4**: 修改撥款程式,自動扣除補償金額
5. ✅ **步驟 5**: 建立補償報表,追蹤執行狀況
6. ✅ **步驟 6**: 通知受影響的商家
7. ✅ **步驟 7**: 實施預防措施,避免再次發生

### 關鍵注意事項

1. **資料備份**: 執行任何 UPDATE/INSERT 前,先備份相關資料表
2. **測試環境**: 先在測試環境驗證 SQL 正確性
3. **分批處理**: 如果影響筆數很多,建議分批處理
4. **雙重確認**: 扣款金額計算務必人工再次核對
5. **文件記錄**: 完整記錄每次操作的結果和影響

### 後續追蹤

- 每次撥款後,檢查補償記錄是否正常扣除
- 定期檢視 `Grant_Compensation` 表中 `Status='Pending'` 的記錄
- 如果某商家長期沒有訂單,考慮通知其主動清償欠款
